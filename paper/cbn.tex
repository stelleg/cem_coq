\section{Call-by-need}

Call-by-need semantics ensures that arguments are only evaluated when needed,
when needed, and memoize the result so that they are only evaluated once. This
is in contrast to the more common call-by-value, which always evaluates
arguments, and call-by-name, which evaluates arguments for every corresponding
variable dereference. Each semantics has advantages and drawbacks, and
increasingly programming languages are incorporating the ability to switch
between them \cite{?}. 

Our source language is Ariola et al.'s call-by-need lambda calculus \cite{?}. It
is an untyped language with the standard lambda calculus for it's syntax: 

  $$ t := x \; | \; \lambda x . t \; | \; t \; t $$

Ariola et al. give a few different versions of their semantics. To ease 
proof burdens, we use the operational semantics, though formalizing the
syntactic account and it's connection to the operational semantics would be
interesting future work. The semantics are given in Figure~\ref{cbn}. 

Unfortunately the operational semantics have a known issue, which was
independently exposed during our formalization. The issue is that upon
evaluation of a dereferenced variable, part of the heap is forgotten. When
adding fresh variables, the semantics requires that they are fresh with respect
only to the \emph{current} heap, but when merging back with the previously
forgotten heap in the Id rule, the semantics can break the invariant that every
address in the domain of the heap is unique, and can therefore perform incorrect
evaluation. For an example of how it can go wrong see Figure~\ref{cbnwrong}, 

To fix this problem, instead of throwing away the unreachable part of the heap
in the Id rule, we keep it around, but separate the reachable heap from the
unreachable explicitly. We then ensure that freshness is enforced with respect
to both the unreachable and reachable parts of the heap, preventing the issue
described above. This fix has the additional benefit that it simplifies the
relationship to machine code, keeping the heap in tact as a global entity, in
contrast to existing fixes to this issue \cite{?}. The fixed semantics are shown
in Figure~\ref{fig:cbnfixed}. The reachable and unreachable heaps are seperated by
the \texttt{\&} character.

\begin{figure}
\lstinputlisting{cbnbroken.v}
\caption{Original, broken call-by-need semantics}
\label{fig:cbnbroken}
\end{figure}

\begin{figure}
\lstinputlisting{cbnfixed.v}
\caption{Fixed call-by-need semantics}
\label{fig:cbnfixed}
\end{figure}

One might be tempted to ignore the ordering of the heap bindings and try and
reason about a monolithic heap directly. The difficulty that arises with this
approach is that for the Id rule we need to retain that the expression being
entered is unchanged before the update: i.e. there are no cycles in the heap. 
When working with a monolithic heap, one needs to reason about this acyclic
property directly. Unfortunately this approach is much more difficult, as it
requires a lemma showing that unreachable heap locations \emph{stay}
unreachable. Using the approach of Ariola et al. of gives us a much simpler to
reason about approximation of reachability. 

An important property in the proof of bisimulation will be \emph{well-formed}
property. We use the definition directly of Ariola et al., namely that every
term in the heap is \emph{closed to the left}, that is, the free variables of a
term in the heap are in the domain of the heap to the left of said term. In
addition, the term being evaluated is closed under the reachable heap, and all
domain variables are unique with respect to both the reachable and unreachable
heaps. We prove the following lemma, that well-formedness is preserved through
evaluation: 

\begin{lstlisting}
Lemma well_formed_step : ∀ c1 c2, well_formed c1 → c1 ⇓ c2 → well_formed c2.
\end{lstlisting}


For simplicity of formalization, we choose to follow the convention of Ariola et
al. that when we bind a new variable to a new term in the heap, we ensure that
that variable is fresh with respect to both the heap and the term we will be
substituting into.  This prevents reasoning directly about garbage collection
or re-use of heap locations. We will return to this issue in the discussion
section, but it is worth keeping in mind throughout the paper that relaxing the
freshness constraint to being fresh with respect to \emph{live} or
\emph{reachable} heap locations should be possible, and is an interesting
opportunity for future work. 

\subsection{Call-by-name}
An important property of call-by-need is that it is an optimized implementation of
the simpler call-by-name semantics: 

\begin{align}
\inference{l \downarrow \lambda x. b \quad \quad b [m / x] \downarrow v}{l \; m \downarrow v}
\end{align}

Formally, this means that any expression that evaluates to a value in
call-by-name will evaluate to an equivalent value in call-by-need. This is a
valuable property to have, because it means we can reason about
\emph{correctness} properties of a source language, e.g. type preservation,
using these simpler evaluation semantics. 

It's worth noting here that there are cases when requiring call-by-need
semantics is detrimental to performance. The basic idea is that there are cases
when storing a value and referencing it later is more expensive than re-creating
it on demand. For example, the function \texttt{mean xs = sum xs / length xs}
when called on a something like \texttt{[1..10000]} will memoize the list in
memory for the call to \texttt{sum}, then traverse it to compute the
\texttt{length}.  If the memoization restriction was lifted to permit any
non-strict semantics, like call-by-name, this operation could be computed more
quickly entirely in machine registers. While we choose to verify compilation of
simpl call-by-need semantics, we'll return to this discussion of relaxed
non-strict semantics in the Discussion section.

